---
title: "Rubyの言語仕様2"
permalink: /ruby/ruby-spec2/
toc: true
---
## メソッド
これまで、画面に出力する`puts`メソッドや、キーボードからの入力を文字列に変換する`gets`メソッド、
また行末の改行を削除する`chomp`メソッドや、文字列を整数に変換する`to_i`メソッドを使ってきました。

ここでは、メソッドについてもう少し詳しく説明します。

### メソッドとは
メソッドとは、おおまかに言うと、関数のようなものです。

数学の関数を説明すると、

<img src="https://render.githubusercontent.com/render/math?math=%5CLarge+f%28x%2Cy%29+%3D+x%5E2+%2B+y%5E2">

という**関数f**が定義されているとするとします。

この**関数f**に対し、**x=2**、**y=3**とすると、**関数f**は**13**を返します。

Rubyのメソッドも同様に、（引数として）渡したオブジェクト（値など）を使って、あらかじめ定義された処理を行い、結果としてオブジェクト（値など）を返したり、オブジェクトに影響を与えたりします。

一般的なメソッド呼び出しの書き方は、以下のようになります。

```ruby
オブジェクト.メソッド名(引数1, 引数2, ・・・・, 引数n)
```

また、メソッドには、以下のような特徴があります。

1. メソッドはオブジェクト内で定義されている。
2. オブジェクトは、省略できる場合がある。
3. メソッド名は、半角英小文字または`_`から始める。途中に半角数字を含めても良い。
4. 引数の丸カッコ`()`は省略できる。
5. 引数が必要かどうかは、メソッドの定義による。引数を必要としないメソッドもある。
6. メソッドは、オブジェクト(値など)を返す。

Rubyのメソッドは、Ruby内部で数多く定義されています。しかし、すべてのメソッドを覚えている人は、（ほとんど）いませんし、覚える必要もありません。
プログラミングでは、**こういう処理をしたい**と思った時に、まずは、Rubyのリファレンスや参考書籍などを見たり、インターネットで検索します。

見つかれば、そのメソッドの使い方を調べて、分かりやすく効率的な書き方を考えて、自分のプログラムに書きます。

慣れてくると、だいたいあのメソッドを使えばできそうとか、あの辺りを調べる（検索する）と出てきそうなどと、当たりをつけることができるので、より早くプログラムが書けるようになります。

言ってしまえば、プログラミングは**覚えるより慣れろ**です（筆者の個人的な意見）。

### メソッドの定義
メソッドは、プログラム上で独自のメソッドを定義することができます。特に、繰り返し使う場合は有効です。

メソッド定義の書き方は、以下のようになります。

```ruby
def メソッド名(引数1, 引数2, ・・・, 引数n)
  処理
end
```

最後に処理した（行の）結果が、自動的に戻り値となります。明示的に記述したい場合は、**return**文を使います。

上記の関数`f`をRubyで定義すると、以下のようになります。

```ruby
def f(x, y)
  # Rubyでのべき乗演算子は**です。
  return x**2 + y**2 # returnはなくても正しく動作します。
end
```

**f**メソッドを使ったプログラムの例は、以下のようになります。

```ruby
number1 = gets.chomp.to_i
number2 = gets.chomp.to_i
result = f(number1, number2)
puts "結果：#{result}"
```

プログラムを実行すると、以下のようになります。

```bash
2
3
結果：13
```

<figure>
  <img src="{{ '/assets/images/ruby/07/method.png' | relative_url }}" alt="Method">
</figure>

プログラムに直接メソッド定義を書くと、メソッド呼び出しの**オブジェクト.**は省略できます。

後半で説明する**クラス**の定義内でメソッドを定義すると、**クラスのオブジェクト.メソッド名(引数)**という書き方になります。

## データ構造
Rubyでは、複数のオブジェクト（値など）を一度に扱うための仕組み（データ構造）が用意されています。
ここでは、配列（Array）とハッシュ（Hash）を説明します。

### 配列（Array）
配列は、データを順番に入れておく箱のようなものです。角括弧`[]`を使って表現します。

以下が、配列の例です。

```ruby
[] # 空の配列
[5, 394, 3.14, -4] # 数値（整数、実数混ぜても可）
["バナナ", "りんご", "パイナップル", "梨"] # 文字列
["アメリカ", 327750000, "日本", 125810000, "インド",　1334220000] # ミックスも可
```

データの位置には番号（インデックス）が振ってあります。配列の先頭が0で、以下1, 2, 3, ・・・と増えていきます。

特定のデータを取得するには、角括弧`[]`を使ってインデックスを指定します。

配列のデータの取得、入れ替えの例です。

```ruby
ary = ["バナナ", "りんご", "パイナップル", "梨"] 
puts ary[1] # りんごと表示
ary[1] = "アップル" # 2番目のデータを書き換え
puts ary[1] # アップルと表示
```

配列を扱うメソッドや構文はいくつもありますが、ここでは追加と削除の例です。

配列の追加、削除の例です。

```ruby
ary << "キウイ" # 末尾にキウイを追加
puts ary[4] # キウイと表示
ary.delete_at(2) # パイナップルを削除
puts ary[3] # キウイと表示
```

配列には、先頭から順番にデータを取り出す便利なメソッド**each**があります。

**each**メソッドの書き方は、以下のようになります。

```ruby
配列.each do |引数|
  引数を使った処理
end
```

配列の先頭からデータを一つずつ**引数**に入れ、`do`と`end`の間の行で、**引数**を使った処理を行います。

以下が、**each**メソッドを使った例です。

```ruby
populations = ["アメリカ", 327750000, "日本", 125810000, "インド", 1334220000]

gusu = true
populations.each do |data|
  if gusu
    print "#{data}の人口："
    gusu = false
  else
    puts "#{data}人"
    gusu = true
  end
end
```

プログラムを実行すると、以下のようになります。

```bash
アメリカの人口：327750000人
日本の人口：125810000人
インドの人口：1334220000人
```

<figure>
  <img src="{{ '/assets/images/ruby/07/array.png' | relative_url }}" alt="Array">
</figure>

### ハッシュ（Hash）
ハッシュは、データを**キー**と**バリュー**のペアで入れておく箱のようなものです。波括弧`{}`を使って表現します。

ペアは、`キー => バリュー`や、`キー: バリュー`で表します。

以下が、ハッシュの例です。

```ruby
{} # 空のハッシュ
{0 => "バナナ", 1 => "りんご", 2 => "パイナップル", 3 => "梨"} # キーが整数、バリューが文字列の例
{"アメリカ" => 327750000, "日本" => 125810000, "インド" => 1334220000} # キーが文字列、バリューが整数の例
{jp: "日本", kr: "韓国", cn: "中国", fr: "フランス", de: "ドイツ"} # キー:表記を使った例
```

ハッシュは、主にキーを角括弧`[]`を使って指定して、バリューの値を取得します。

ハッシュのバリューの取得、入れ替えの例です。

```ruby
hash = {0 => "バナナ", 1 => "りんご", 2 => "パイナップル", 3 => "梨"} 
puts hash[1] # りんごと表示
hash[1] = "アップル" # キー1のバリューを書き換え
puts hash[1] # アップルと表示
```

ハッシュを扱うメソッドや構文はいくつもありますが、ここでは追加と削除の例です。

ハッシュの追加、削除の例です。

```ruby
hash[4] << "キウイ" # キー4にキウイを追加
puts hash[4] # キウイと表示
hash.delete(2) # キー2とバリューパイナップルのペアを削除
puts hash[2] # キー2がないので何も表示されない
```

ハッシュにも、キーとバリューのペアデータを一つずつ取り出す便利なメソッド**each**があります。

**each**メソッドの書き方は、以下のようになります。

```ruby
ハッシュ.each do |引数1（キーに対応), 引数2（バリューに対応）|
  引数1、引数2を使った処理
end
```

ハッシュの先頭からキーとバリューのペアデータを一つずつ取り出し、**引数1**に**キー**を、**引数2**に**バリュー**を入れ、`do`と`end`の間の行で、**引数1**と**引数2**を使った処理を行います。

以下が、**each**メソッドを使った例です。

```ruby
populations = {"アメリカ" => 327750000, "日本" => 125810000, "インド" => 1334220000}

populations.each do |data_key, data_value|
  puts "#{data_key}の人口：#{data_value}人"
end
```

プログラムを実行すると、以下のようになります。

```bash
アメリカの人口：327750000人
日本の人口：125810000人
インドの人口：1334220000人
```

<figure>
  <img src="{{ '/assets/images/ruby/07/hash.png' | relative_url }}" alt="Hash">
</figure>

データをどう扱うかによって、配列とハッシュをうまく使い分けます。
{: .notice--info}

## オブジェクト指向
Rubyは、**オブジェクト指向言語**です。オブジェクト指向の概念は、かなり難しく、理解するにはしっかり学ぶ必要があります。

ここでは、簡単な説明と、Rubyでのオブジェクト指向の使い方について説明します。

すぐに理解できなくても大丈夫です。クラス（後述）を使っていくうちに、次第に理解できます。
{: .notice--info}

### オブジェクト指向とは
オブジェクト（Object）を日本語に訳すと**物体**や**対象**です。これでは、意味が分かりません。プログラミングでのオブジェクトとはどういう意味でしょうか。

- [**Wikipedia**](https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)){:target="_blank"} プログラミングにおいて、プログラム上の手続きの対象を抽象化する概念。

- **e-Words**[^1] ソフトウェアが扱おうとしている現実世界に存在する物理的あるいは抽象的な実体を、属性(データ)と操作(メソッド)の集合としてモデル化し、コンピュータ上に再現したもの。

[^1]: 出典の内容が変更されましたが、以前掲載されていた内容をここでは使用しています。

概念を簡単に図解すると以下のようなイメージです。

<figure>
  <img src="{{ '/assets/images/ruby/07/object.png' | relative_url }}" alt="Object">
</figure>

では、実際に現実のものにこの抽象的な概念が当てはまるでしょうか。実物のテレビで考えてみます。

<figure>
  <img src="{{ '/assets/images/ruby/07/television_hw.png' | relative_url }}" alt="Television HW">
</figure>

当てはまりそうですね。それでは、テレビアプリの場合はどうでしょうか。

<figure>
  <img src="{{ '/assets/images/ruby/07/television_sw.png' | relative_url }}" alt="Television SW">
</figure>

当てはまりますね。よく見ると、実物でもアプリでも抽象化すると、同じデータやメソッドを持ちそうです。

あたかも、**もの=機械**を設計し、設計図どおりに（大量）生産するかのように、プログラムで、**もの=アプリ**を設計し、設計図どおりに（大量）生産する書き方を**オブジェクト指向**と言います。

Rubyには、**オブジェクト指向**でプログラムを書くための、仕組みが備わっています。

オブジェクト指向プログラミング言語は、**継承**、**ポリモルフィズム**、**カプセル化**の特徴があります。  
とても難しいので、ここでは省略します。
{: .notice--info}

### クラス（Class）とは
クラス（Class）とは、オブジェクトの設計書と言えます。具体的には、オブジェクトが扱うデータとメソッド（処理）の定義書です。

Rubyの内部では、多数のメソッドが定義されていると言いました。
より厳密に言えば、**多くのクラスが定義され、その中に多くのメソッドが定義されている**ということになります。

これまで言及しませんでしたが、Rubyでは、文字列や数値はオブジェクトです。つまり、クラスとして定義されています。配列やハッシュも同様です。

<figure>
  <img src="{{ '/assets/images/ruby/07/class.png' | relative_url }}" alt="Class">
</figure>

[Rubyリファレンスマニュアル](https://docs.ruby-lang.org/ja/2.7.0/library/_builtin.html){:target="_blank"}には、多くのクラスが記載してあります。

Rubyには、**組み込みライブラリ**と**標準添付ライブラリ**があります。**組み込みライブラリ**は、使用頻度が多い重要なクラスが定義されています。**標準添付ライブラリ**は、必要な時に（明示的に）呼び出して使うクラスが定義されています。
{: .notice--info}

### クラスの定義
メソッドと同様に、プログラム上で独自のクラスを定義することができます。

クラス定義の書き方はいろいろあり、また複雑ですが、基本的には以下のようになります。

```ruby
def クラス名
  attr_accessor :変数1, :変数2, ・・・, 変数n

  def initialize(引数1, 引数2, ・・・, 引数n)
    変数の初期化など
  end

  def メソッドA名(引数A1, 引数A2, ・・・, 引数An)
    メソッド1の処理
  end

  def メソッドB名(引数B1, 引数B2, ・・・, 引数Bn)
    メソッド2の処理
  end

  ・・・
end
```

テレビの設計書から、テレビの実体を製造するように、プログラムでも、クラス定義からクラスの実体を生成します。

クラスの実体を**オブジェクト**と呼びますが、オブジェクトは広い意味で使われることもあるので、このクラスの実体を特に**インスタンス**と呼びます。

一般的なクラスの実体を生成する書き方は、以下のようになります。

```ruby
クラス名.new(引数1, 引数2, ・・・・, 引数n)
```

クラスには、以下のような特徴があります。

1. クラス名は、半角英大文字から始める。
2. **new**メソッドが呼ばれると、自動的にクラス定義内の**initialize**メソッドが実行される。
3. 必要なければ**initialize**メソッドを定義しなくてよい。また、引数は必須ではない。
4. 変数名は、半角英小文字または`_`から始める。途中に半角数字を含めても良い。
5. メソッド内で変数を使うことができる。その場合、先頭に`@`を付ける必要がある。

### クラスを使ったプログラム
クラスの使用例として、[数当てゲーム](/archives/ruby/create-simple-games/#仕上げ){:target="_blank"}のプログラムをクラス定義に適用してみます。

```ruby
# プログラム名：数当てゲーム（number-guessing-game.rb）
# 説明：ランダム生成した整数を予測して当てるゲーム

# クラス定義
Class NumberGuessingGame
  attr_accessor :seikai, :hazure # これは書かなくてもよいです

  def initialize()
    @seikai = rand(1..100)
    @hazure = true
    super
  end

  def start
    self.description
    self.game
    self.finish
  end

  def description
    puts "数当てゲーム"
    puts "1から100までの整数をランダム生成します。その数を当ててください。"
  end

  def game
    while @hazure
      print "正解と思う整数を入力してください："
      nyuryoku = gets.chomp.to_i
      hyouka(nyuryoku)
    end
  end

  def hyouka(input)
    if @seikai < input
      puts "正解は入力値より小さいです。"
    elsif @seikai > input
      puts "正解は入力値より大きいです。"
    else
      @hazure = false
    end
  end

  def finish
    puts "正解です。"
  end
end

# クラスのインスタンス化と実行
game = NumberGuessingGame.new
game.start
```

説明してないことも多く含まれています。分からないところは、調べてみてください。

クラス定義やクラスの使い方については、まだまだいろいろあります。
{: .notice--info}
